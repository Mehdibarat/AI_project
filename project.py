# -*- coding: utf-8 -*-
"""Copy of Welcome To Colaboratory

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q5tkKfRAt7s7Zu_iPUWex8-_-HWXVhGp
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from sklearn.model_selection import train_test_split

from sklearn.preprocessing import MinMaxScaler

from sklearn.tree import DecisionTreeClassifier

from sklearn.metrics import classification_report, accuracy_score, recall_score, precision_score, f1_score, ConfusionMatrixDisplay

from sklearn.neighbors import KNeighborsClassifier

from sklearn.linear_model import  LogisticRegression

from sklearn.ensemble import  RandomForestClassifier

from sklearn.naive_bayes import GaussianNB

df = pd.read_csv('mobile.csv')
df

"""SHOW DATA FEATURE"""

df.info()

df.describe().T

"""for show in scater plot based on price range ,first have to convet to numeric"""

df['price_range'].replace({'low price' : 0,'medium low' : 1 , 'medium high' : 2,'high' : 3}, inplace=True)

plt.boxplot(df['battery_power'].dropna())
plt.title('Boxplot of battery_power')
plt.ylabel('value')

plt.boxplot(df['clock_speed'].dropna())
plt.title('Boxplot of clock_speed')
plt.ylabel('value')

plt.boxplot(df['fc'].dropna())
plt.title('Boxplot of fc')
plt.ylabel('value')

plt.title('Scatter Plot to Find Outliers')
plt.xlabel('fc')
plt.ylabel('index')
plt.scatter(df['fc'], df['index'], c = df['price_range'], cmap='coolwarm')
#plt.grid()
plt.show()

plt.boxplot(df['int_memory'].dropna())
plt.title('Boxplot of int_memory')
plt.ylabel('value')

plt.boxplot(df['m_dep'].dropna())
plt.title('Boxplot of m_dep')
plt.ylabel('value')

plt.boxplot(df['mobile_wt'].dropna())
plt.title('Boxplot of mobile_wt')
plt.ylabel('value')

plt.boxplot(df['n_cores'].dropna())
plt.title('Boxplot of n_cores')
plt.ylabel('value')

plt.boxplot(df['pc'].dropna())
plt.title('Boxplot of pc')
plt.ylabel('value')

plt.boxplot(df['px_height'].dropna())
plt.title('Boxplot of px_height')
plt.ylabel('value')

plt.title('Scatter Plot to Find Outliers')
plt.xlabel('px_height')
plt.ylabel('index')
plt.scatter(df['px_height'], df['index'], c = df['price_range'], cmap='coolwarm')
#plt.grid()
plt.show()

plt.boxplot(df['px_width'].dropna())
plt.title('Boxplot of px_width')
plt.ylabel('value')

plt.boxplot(df['ram'].dropna())
plt.title('Boxplot of ram')
plt.ylabel('value')

plt.boxplot(df['sc_h'].dropna())
plt.title('Boxplot of sc_h')
plt.ylabel('value')

plt.boxplot(df['sc_w'].dropna())
plt.title('Boxplot of sc_w')
plt.ylabel('value')

"""Outlier Detection in all feeature"""

plt.boxplot(df['talk_time'].dropna())
plt.title('Boxplot of talk_time')
plt.ylabel('value')

"""Remove outlier of feature"""

df = df[df['fc'].between(0, 16) | pd.isna(df['fc'])]
df

plt.boxplot(df['fc'].dropna())
plt.title('Boxplot of fc')
plt.ylabel('value')

plt.title('Scatter Plot after delete  Outliers')
plt.xlabel('fc')
plt.ylabel('index')
plt.scatter(df['fc'], df['index'], c = df['price_range'], cmap='coolwarm')
#plt.grid()
plt.show()

df = df[df['px_height'].between(0, 1940) | pd.isna(df['px_height'])]
df

plt.boxplot(df['px_height'].dropna())
plt.title('Boxplot of px_height')
plt.ylabel('value')

plt.title('Scatter Plot after delete Outliers')
plt.xlabel('px_height')
plt.ylabel('index')
plt.scatter(df['px_height'], df['index'], c = df['price_range'], cmap='coolwarm')
#plt.grid()
plt.show()

"""Check duplicated rows

NO duplicated!!
"""

df[df.duplicated()]

df.info()

"""turn Categorical to Numeric"""

df['blue'].replace({'no' : 0,'yes' : 1 }, inplace=True)

df['sim type'].replace({'one' : 1,'dual' : 2 }, inplace=True)

df['four_g'].replace({'no' : 0,'yes' : 1 }, inplace=True)

df['three_g'].replace({'yes' : 1,'no' : 0 }, inplace=True)

df['type'].replace({'touch screen' :0,'button' :1}, inplace=True)

df['wifi'].replace({'has wifi' : 1,'no wifi' : 0 }, inplace=True)
df

f3_median = df['battery_power'].median()
df['battery_power'] = df['battery_power'].fillna(f3_median)

f3_median = df['four_g'].median()
df['four_g'] = df['four_g'].fillna(f3_median)

f3_median = df['blue'].median()
df['blue'] = df['blue'].fillna(f3_median)

f3_median = df['clock_speed'].median()
df['clock_speed'] = df['clock_speed'].fillna(f3_median)

f3_median = df['sim type'].median()
df['sim type'] = df['sim type'].fillna(f3_median)

f3_median = df['m_dep'].median()
df['m_dep'] = df['m_dep'].fillna(f3_median)

f3_median = df['mobile_wt'].median()
df['mobile_wt'] = df['mobile_wt'].fillna(f3_median)

f3_median = df['n_cores'].median()
df['n_cores'] = df['n_cores'].fillna(f3_median)

f3_median = df['pc'].median()
df['pc'] = df['pc'].fillna(f3_median)

f3_median = df['px_height'].median()
df['px_height'] = df['px_height'].fillna(f3_median)

f3_median = df['px_width'].median()
df['px_width'] = df['px_width'].fillna(f3_median)

f3_median = df['ram'].median()
df['ram'] = df['ram'].fillna(f3_median)

f3_median = df['sc_h'].median()
df['sc_h'] = df['sc_h'].fillna(f3_median)

f3_median = df['sc_w'].median()
df['sc_w'] = df['sc_w'].fillna(f3_median)

f3_median = df['talk_time'].median()
df['talk_time'] = df['talk_time'].fillna(f3_median)

f4_median = df['three_g'].median()
df['three_g'] = df['three_g'].fillna(f4_median)

f4_median = df['type'].median()
df['type'] = df['type'].fillna(f4_median)

f4_median = df['wifi'].median()
df['wifi'] = df['wifi'].fillna(f4_median)

df.info()

"""Split Train AND Test

"""

X = df.drop(columns=['price_range', 'index'])
X

y = df['price_range']
y

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=0)

print('X shape: ', X.shape)
print('X_train shape: ', X_train.shape)
print('X_test shape: ', X_test.shape)
print()
print('y shape:', y.shape)
print('y_train shape: ', y_train.shape)
print('y_test shape: ', y_test.shape)

"""Scale numbers to between 0/1"""

scaler = MinMaxScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

pd.DataFrame(X_train)

"""MODELS
DESICION TREE AND KNN
"""

model = DecisionTreeClassifier(random_state=0)
model

model.fit(X_train, y_train)

model.predict(X_test)

y_pred = model.predict(X_test)

print(classification_report(y_test, y_pred))

print('Accuracy: ', accuracy_score(y_test, y_pred))
print('Precision: ', precision_score(y_test, y_pred,average='micro'))
print('Recall: ', recall_score(y_test, y_pred,average='micro'))
print('F1-Score: ', f1_score(y_test, y_pred,average='micro'))

ConfusionMatrixDisplay.from_predictions(y_test, y_pred)

model = KNeighborsClassifier(n_neighbors=8)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)
print(classification_report(y_test, y_pred))

print('Accuracy: ', accuracy_score(y_test, y_pred))
print('Precision: ', precision_score(y_test, y_pred,average='micro'))
print('Recall: ', recall_score(y_test, y_pred,average='micro'))
print('F1-Score: ', f1_score(y_test, y_pred,average='micro'))

ConfusionMatrixDisplay.from_predictions(y_test, y_pred)

model = LogisticRegression()
model.fit(X_train, y_train)
y_pred = model.predict(X_test)
print(classification_report(y_test, y_pred))

print('Accuracy: ', accuracy_score(y_test, y_pred))
print('Precision: ', precision_score(y_test, y_pred,average='micro'))
print('Recall: ', recall_score(y_test, y_pred,average='micro'))
print('F1-Score: ', f1_score(y_test, y_pred,average='micro'))

ConfusionMatrixDisplay.from_predictions(y_test, y_pred)

model = RandomForestClassifier(n_estimators=100,random_state=42)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)
print(classification_report(y_test, y_pred))

print('Accuracy: ', accuracy_score(y_test, y_pred))
print('Precision: ', precision_score(y_test, y_pred,average='micro'))
print('Recall: ', recall_score(y_test, y_pred,average='micro'))
print('F1-Score: ', f1_score(y_test, y_pred,average='micro'))

ConfusionMatrixDisplay.from_predictions(y_test, y_pred)

model = GaussianNB()
model.fit(X_train, y_train)
y_pred = model.predict(X_test)
print(classification_report(y_test, y_pred))

print('Accuracy: ', accuracy_score(y_test, y_pred))
print('Precision: ', precision_score(y_test, y_pred,average='micro'))
print('Recall: ', recall_score(y_test, y_pred,average='micro'))
print('F1-Score: ', f1_score(y_test, y_pred,average='micro'))

ConfusionMatrixDisplay.from_predictions(y_test, y_pred)